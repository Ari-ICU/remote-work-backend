import { Test, TestingModule } from '@nestjs/testing';
import { INestApplication, ValidationPipe } from '@nestjs/common';
import * as request from 'supertest';
import { AppModule } from '../src/app.module';

describe('Penetration Testing (e2e)', () => {
    let app: INestApplication;
    let employerToken: string;
    let freelancerToken: string;
    let otherFreelancerToken: string;
    let testJobId: string;

    beforeAll(async () => {
        const moduleFixture: TestingModule = await Test.createTestingModule({
            imports: [AppModule],
        }).compile();

        app = moduleFixture.createNestApplication();
        app.useGlobalPipes(new ValidationPipe({ whitelist: true, forbidNonWhitelisted: true }));
        await app.init();

        // 1. Create and authenticate an Employer
        const employerData = {
            email: `employer_${Date.now()}@test.com`,
            password: 'Password123!',
            firstName: 'Test',
            lastName: 'Employer',
            role: 'EMPLOYER'
        };
        await request(app.getHttpServer()).post('/auth/register').send(employerData);
        const employerLogin = await request(app.getHttpServer()).post('/auth/login').send({
            email: employerData.email,
            password: employerData.password
        });
        employerToken = employerLogin.body.accessToken;

        // 2. Create and authenticate a Freelancer
        const freelancerData = {
            email: `freelancer_${Date.now()}@test.com`,
            password: 'Password123!',
            firstName: 'Test',
            lastName: 'Freelancer',
            role: 'FREELANCER'
        };
        await request(app.getHttpServer()).post('/auth/register').send(freelancerData);
        const freelancerLogin = await request(app.getHttpServer()).post('/auth/login').send({
            email: freelancerData.email,
            password: freelancerData.password
        });
        freelancerToken = freelancerLogin.body.accessToken;

        // 3. Create and authenticate another Freelancer (to test BOLA/IDOR)
        const otherFreelancerData = {
            email: `other_${Date.now()}@test.com`,
            password: 'Password123!',
            firstName: 'Other',
            lastName: 'Freelancer',
            role: 'FREELANCER'
        };
        await request(app.getHttpServer()).post('/auth/register').send(otherFreelancerData);
        const otherLogin = await request(app.getHttpServer()).post('/auth/login').send({
            email: otherFreelancerData.email,
            password: otherFreelancerData.password
        });
        otherFreelancerToken = otherLogin.body.accessToken;

        // 4. Employer creates a job
        const jobResponse = await request(app.getHttpServer())
            .post('/jobs')
            .set('Authorization', `Bearer ${employerToken}`)
            .send({
                title: 'Pen Test Job',
                description: 'Testing security',
                category: 'Testing',
                budget: 100,
                budgetType: 'FIXED',
                skills: ['Test']
            });

        testJobId = jobResponse.body.id;
        if (!testJobId) {
            console.error('Failed to create test job:', jobResponse.body);
        }
    });

    afterAll(async () => {
        await app.close();
    });

    describe('IDOR / BOLA (Broken Object Level Authorization)', () => {
        it('FREELANCER should NOT be able to delete a job posted by EMPLOYER', async () => {
            // Freelancer tries to delete Employer's job
            return request(app.getHttpServer())
                .delete(`/jobs/${testJobId}`)
                .set('Authorization', `Bearer ${freelancerToken}`)
                .expect(403); // Forbidden
        });

        it('FREELANCER should NOT be able to view another freelancer\'s application list', async () => {
            // Trying to list applications for a job they didn't post (and are not admin)
            return request(app.getHttpServer())
                .get(`/applications/job/${testJobId}`)
                .set('Authorization', `Bearer ${freelancerToken}`)
                .expect(403); // Managed by ForbiddenException
        });

        it('EMPLOYER should NOT be able to apply for their own job', async () => {
            return request(app.getHttpServer())
                .post(`/applications/${testJobId}`)
                .set('Authorization', `Bearer ${employerToken}`)
                .send({
                    coverLetter: 'I am applying to my own job',
                    proposedRate: 50,
                    estimatedTime: '1 week',
                    status: 'PENDING'
                })
                .expect(400); // Bad Request: "You cannot apply for your own job"
        });
    });

    describe('BFLA (Broken Function Level Authorization)', () => {
        it('FREELANCER should NOT be able to access Admin stats', async () => {
            return request(app.getHttpServer())
                .get('/admin/stats')
                .set('Authorization', `Bearer ${freelancerToken}`)
                .expect(403); // Managed by RolesGuard
        });
    });

    describe('Injection Attacks', () => {
        it('SQL Injection: should NOT allow leaking data via title', async () => {
            const response = await request(app.getHttpServer())
                .post('/jobs')
                .set('Authorization', `Bearer ${employerToken}`)
                .send({
                    title: "Title' OR '1'='1",
                    description: "Testing injection",
                    category: 'Testing',
                    budget: 100,
                    budgetType: 'FIXED',
                    skills: ['Injection']
                });

            expect(response.status).toBe(201);
            expect(response.body.title).toBe("Title' OR '1'='1");
        });

        it('XSS Injection: should NOT execute script in description (Verification of Sanitization)', async () => {
            const xssContent = "<script>alert('xss')</script>";
            const response = await request(app.getHttpServer())
                .post('/jobs')
                .set('Authorization', `Bearer ${employerToken}`)
                .send({
                    title: "XSS Test",
                    description: xssContent,
                    category: 'Testing',
                    budget: 100,
                    budgetType: 'FIXED',
                    skills: ['XSS']
                });

            expect(response.status).toBe(201);
            expect(response.body.description).toBe(xssContent);
        });
    });

    describe('Business Logic Vulnerability', () => {
        it('should NOT allow negative budget in jobs', async () => {
            // This tests if our DTO and logic handles common business logic errors
            return request(app.getHttpServer())
                .post('/jobs')
                .set('Authorization', `Bearer ${employerToken}`)
                .send({
                    title: 'Negative Budget Job',
                    description: 'Testing budget',
                    category: 'Testing',
                    budget: -100,
                    budgetType: 'FIXED',
                    skills: ['Test']
                })
                .expect(400); // Should be caught by class-validator
        });
    });
});
